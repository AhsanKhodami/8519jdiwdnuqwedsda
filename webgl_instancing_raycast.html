<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - instancing - raycast</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body { margin: 0; overflow: hidden; }
			/* Disable context menu everywhere */
			* { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
			/* Enhanced loading visuals */
			.loading-gradient {
				background: radial-gradient(circle at 30% 30%, #2a002a, #050505 70%) !important;
				animation: pulseBg 6s linear infinite;
			}
			@keyframes pulseBg { 0%,100% { filter: brightness(1); } 50% { filter: brightness(1.25); } }
			.loader-spinner {
				width: 96px; height: 96px; position: relative; margin-bottom: 28px;
			}
			.loader-spinner:before, .loader-spinner:after {
				content: ""; position: absolute; inset:0; border-radius:50%;
				background: conic-gradient(from 0deg, #ff0040, #ff9a3c, #ffd23f, #ff0040);
				animation: spin 1.8s linear infinite;
				filter: blur(2px);
			}
			.loader-spinner:after { inset:10px; background:#111; filter:none; animation:none; box-shadow:0 0 4px #ff0040 inset, 0 0 12px #ff0040; }
			@keyframes spin { to { transform: rotate(360deg); } }
			.progress-wrapper { width: 340px; max-width:70vw; }
			.progress-bar {
				height: 10px; width:100%; background:rgba(255,255,255,0.12); border-radius:6px; overflow:hidden; box-shadow:0 0 0 1px rgba(255,255,255,0.08) inset;
				margin-top:18px; position:relative;
			}
			.progress-fill {
				--p:0%;
				width:var(--p); height:100%;
				background:linear-gradient(90deg,#ff0040,#ff5e29,#ffb30f);
				box-shadow:0 0 6px #ff0040;
				transition: width .6s cubic-bezier(.4,.17,.3,1);
			}
			.status-line { font-size:15px; letter-spacing:.5px; margin-top:14px; font-weight:500; opacity:.85; }
			.travel-badge { font-size:12px; background:#ff0040; padding:3px 8px; border-radius:12px; margin-bottom:14px; text-transform:uppercase; letter-spacing:1px; box-shadow:0 0 6px #ff0040; }
		</style>
	</head>
	<body oncontextmenu="return false;">
		<!-- STATIC FALLBACK (removed when script succeeds) -->
		<div id="fallback-guide" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;color:#fff;font:14px system-ui,Segoe UI,sans-serif;z-index:9999;padding:28px;">
			<div style="max-width:640px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.15);padding:28px 34px;border-radius:22px;line-height:1.5;">
				<h2 style="margin:0 0 12px;font-size:26px;letter-spacing:.5px;font-weight:600;">Foraging Study – Loading</h2>
				<p style="margin:0 0 14px;opacity:.85">If you only see the berry cube and not the participant / instruction screens, the JavaScript module may not have loaded. This fallback appears when initialization hasn’t completed.</p>
				<ol style="margin:0 0 16px 18px;padding:0;">
					<li>Open this folder with a local server (NOT by double‑click). Example PowerShell: <code>python -m http.server 8000</code> then browse to <code>http://localhost:8000/webgl_instancing_raycast.html</code>.</li>
					<li>Use a modern Chromium / Firefox (import maps required).</li>
					<li>Check DevTools Console for errors (press F12) – look for lines starting with <strong>[Foraging]</strong>.</li>
				</ol>
				<div style="margin:0 0 10px;font-weight:600;letter-spacing:.5px;text-transform:uppercase;font-size:12px;opacity:.85;">Target vs Distractors</div>
				<ul style="list-style:none;margin:0 0 18px;padding:0;display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px;font-size:12.5px;">
					<li style="display:flex;gap:6px;align-items:center;"><span style="width:18px;height:18px;border-radius:50%;background:#ff0040;box-shadow:0 0 4px #ff0040;"></span>Bright Pink = LEFT pick (target)</li>
					<li style="display:flex;gap:6px;align-items:center;"><span style="width:18px;height:18px;border-radius:50%;background:#8b0000;"></span>Dark Red = RIGHT reject</li>
					<li style="display:flex;gap:6px;align-items:center;"><span style="width:18px;height:18px;border-radius:50%;background:#228b22;"></span>Green = RIGHT reject</li>
					<li style="display:flex;gap:6px;align-items:center;"><span style="width:18px;height:18px;border-radius:50%;background:#006400;"></span>Dark Green = RIGHT reject</li>
				</ul>
				<p style="margin:0 0 10px;font-size:12.5px;opacity:.8">Controls: rotate = left‑drag empty space; harvest = left click target; reject = right click distractor; travel = "I'm done here!" (20s jump).</p>
				<p style="margin:0;font-size:12px;opacity:.55">This panel will auto‑hide if the main UI initializes.</p>
			</div>
		</div>
		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from './jsm/jsm/libs/stats.module.js';
			import { OrbitControls } from './OrbitControls.js';

			let camera, scene, renderer, controls, stats;
			let lastPickTime = 0; // debounce duplicate pointer events
			let travelCount = 0; // number of "travels"
			let visibleBerries; // will be (re)allocated per generation
			let instancePositions; // stores Vector3 positions per instance
			let mesh; // current instanced mesh
			let loadingOverlay, loadingText, doneButton; // UI elements
			let participantOverlay, instructionOverlay, appreciationOverlay; // additional overlays
			let startButton, beginButton, finishButton; // control buttons
			const maxTrials = 2; // configurable number of trials (travels) - reduced for testing
			let participant = { name: '', age: '', gender: '' };
			let experimentStartTime = 0;
			let currentTrialStart = 0;
			const clickData = []; // per click records
			const trialData = []; // per trial summary
			let isTargetInstance = []; // boolean per instance for reliable classification
			let lastClickGlobalTime = null; // for inter-click RT
			let lastSummarizedTrial = 0; // avoid duplicate summaries
			let estimatedRefreshHz = null; // estimated display refresh rate
			const layoutData = []; // per-trial berry layout snapshot (targets/distractors before any clicks)
			// Camera rotation tracking
			let rotationCount = 0;
			let rotationTimestamps = [];
			let firstRotationTime = null;
			let isDragging = false;
			let lastDragEndTime = 0;
			let initialCameraAngles = { azimuthal: 0, polar: 0 }; // track starting orientation per trial
			const orientationData = []; // per-rotation orientation log
			let practiceMode = false; // true during practice phase (no data logging)
			let practiceControlPanel = null; // floating panel with Begin Main during practice
			let suppressOverlayRecovery = false; // disables watchdog while practice/main active

			const amount = parseInt( window.location.search.slice( 1 ) ) || 10;
			const count = Math.pow( amount, 3 );

			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2( 1, 1 );

			const color = new THREE.Color();
			const white = new THREE.Color().setHex( 0xffffff );
			
			// Berry colors for foraging task
			const brightCherry = new THREE.Color().setHex( 0xff0040 ); // Bright red cherry (TARGET)
			const darkCherry = new THREE.Color().setHex( 0x8b0000 );   // Dark red cherry (DISTRACTOR)
			const greenBerry = new THREE.Color().setHex( 0x228b22 );   // Green berry (DISTRACTOR)
			const darkGreen = new THREE.Color().setHex( 0x006400 );    // Dark green berry (DISTRACTOR)
			
			// Arrays will be filled in generateBerries()
			visibleBerries = new Array(count);
			instancePositions = new Array(count);

			init();
			// Generate initial field (will be replaced for practice or main start)
			generateBerries();

			function init() {
				console.log('[Foraging] init start');

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( amount, amount, amount );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();

				const light = new THREE.HemisphereLight( 0xffffff, 0x888888, 3 );
				light.position.set( 0, 1, 0 );
				scene.add( light );

				generateBerries();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.enableZoom = false;
				controls.enablePan = false;

				// Gesture-based rotation tracking (one count per deliberate drag)
				let dragActive = false; // internal flag separate from isDragging (trial state variables)
				let dragMoved = false;  // ensure we only count drags that actually move the camera
				const dragThreshold = 0.0005; // minimal angle change to qualify as a rotation gesture
				let lastAz = controls.getAzimuthalAngle();
				let lastPol = controls.getPolarAngle();

				function markRotationGesture(){
					if(!experimentStartTime || !currentTrialStart) return;
					const now = performance.now();
					const trialTime = Math.round(now - currentTrialStart);
					rotationCount++;
					rotationTimestamps.push(trialTime);
					if(firstRotationTime === null) firstRotationTime = trialTime;
					// console.log('[Rotation] gesture', rotationCount, 'at', trialTime+'ms');
				}

				renderer.domElement.addEventListener('pointerdown', (e)=>{
					if(e.button!==0) return; // only left button for rotation gestures
					dragActive = true;
					dragMoved = false;
					lastAz = controls.getAzimuthalAngle();
					lastPol = controls.getPolarAngle();
				});

				renderer.domElement.addEventListener('pointermove', ()=>{
					if(!dragActive) return;
					const az = controls.getAzimuthalAngle();
					const pol = controls.getPolarAngle();
					const dAz = Math.abs(az - lastAz);
					const dPol = Math.abs(pol - lastPol);
					if(dAz > dragThreshold || dPol > dragThreshold){
						dragMoved = true;
					}
				});

				renderer.domElement.addEventListener('pointerup', (e)=>{
					if(!dragActive) return;
					dragActive = false;
					if(e.button===0 && dragMoved){
						// Debounce successive drags separated only by damping frames
						const now = performance.now();
						if(now - lastDragEndTime > 80){ // 80ms gap to separate gestures
							markRotationGesture();
							// Log orientation snapshot
							const az = controls.getAzimuthalAngle();
							const pol = controls.getPolarAngle();
							const trialTime = Math.round(now - currentTrialStart);
							orientationData.push({
								trial: travelCount,
								rotationIndex: rotationCount,
								trialTimeMs: trialTime,
								azimuthalDeg: Math.round(az * 180 / Math.PI * 100)/100,
								polarDeg: Math.round(pol * 180 / Math.PI * 100)/100
							});
						}
						lastDragEndTime = now;
					}
				});

				// In case pointer leaves the canvas
				window.addEventListener('pointerleave', ()=>{ dragActive=false; });

				// (Optional) remove stats overlay to avoid intercepting clicks
				// stats = new Stats();
				// document.body.appendChild( stats.dom );

				createUI();
				createParticipantForm();
				installRecoveryWatchdog();

				window.addEventListener( 'resize', onWindowResize );
				renderer.domElement.addEventListener( 'pointermove', onPointerMove );
				renderer.domElement.addEventListener( 'pointerdown', onPointerDown );
				renderer.domElement.addEventListener( 'contextmenu', (e)=>{ e.preventDefault(); e.stopPropagation(); return false; });
				doneButton.addEventListener( 'click', onTravel );
				
				// Completely disable context menu everywhere
				document.addEventListener('contextmenu', function(e) { e.preventDefault(); return false; });
				window.addEventListener('contextmenu', function(e) { e.preventDefault(); return false; });

			}

			function installRecoveryWatchdog(){
				let attempts = 0;
				const maxAttempts = 8;
				const interval = setInterval(()=>{
					attempts++;
					if(experimentStartTime || practiceMode || suppressOverlayRecovery) { return; }
					const hasOverlay = !!document.querySelector('[data-role="participant-overlay"], [data-role="instruction-overlay"]');
					if(!hasOverlay){
						console.warn('[Foraging] Overlay missing – rebuilding (attempt '+attempts+')');
						try { createParticipantForm(); } catch(e) { console.error('Failed recreate form', e); }
					}
					if(attempts>=maxAttempts) clearInterval(interval);
				}, 1200);
				window.addEventListener('error', (e)=>{
					console.error('[Foraging] Global error', e.message);
					showEmergencyNotice(e.message);
				});
			}

			function showEmergencyNotice(msg){
				if(document.getElementById('foraging-emergency')) return;
				const div = document.createElement('div');
				div.id='foraging-emergency';
				div.style.cssText='position:fixed;top:10px;left:10px;z-index:400;background:#300;padding:10px 14px;color:#fff;font:12px/1.4 system-ui;border:1px solid #f55;border-radius:8px;max-width:260px;';
				div.innerHTML = '<b>UI Recovery</b><br>'+ (msg||'Unknown error') + '<br><button style="margin-top:6px;padding:4px 8px;border:none;background:#f55;color:#fff;border-radius:4px;cursor:pointer;font-weight:600;">Recreate Form</button>';
				div.querySelector('button').onclick=()=>{ createParticipantForm(); };
				document.body.appendChild(div);
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( event ) {
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
			}

			function generateBerries() {
				if ( mesh ) {
					scene.remove( mesh );
					mesh.geometry.dispose();
					mesh.material.dispose();
					mesh = null;
				}
				const geometry = new THREE.IcosahedronGeometry( 0.5, 3 );
				if(practiceMode){
					// In practice we use a smaller randomized set; delegate and exit.
					generatePracticeBerries();
					return;
				}
				const material = new THREE.MeshPhongMaterial( { color: 0xffffff } );
				mesh = new THREE.InstancedMesh( geometry, material, count );
				visibleBerries.fill( true );
				if(isTargetInstance.length !== count) isTargetInstance = new Array(count);
				const offset = ( amount - 1 ) / 2;
				const matrix = new THREE.Matrix4();
				let i = 0;
				for ( let x = 0; x < amount; x ++ ) {
					for ( let y = 0; y < amount; y ++ ) {
						for ( let z = 0; z < amount; z ++ ) {
							const px = offset - x;
							const py = offset - y;
							const pz = offset - z;
							matrix.setPosition( px, py, pz );
							mesh.setMatrixAt( i, matrix );
							instancePositions[i] = new THREE.Vector3( px, py, pz );
							const rand = Math.random();
							if ( rand < 0.3 ) { mesh.setColorAt( i, brightCherry ); isTargetInstance[i] = true; }
							else if ( rand < 0.6 ) { mesh.setColorAt( i, darkCherry ); isTargetInstance[i] = false; }
							else if ( rand < 0.8 ) { mesh.setColorAt( i, greenBerry ); isTargetInstance[i] = false; }
							else { mesh.setColorAt( i, darkGreen ); isTargetInstance[i] = false; }
							i++;
						}
					}
				}
				scene.add( mesh );
				mesh.instanceMatrix.needsUpdate = true;
				if ( mesh.instanceColor ) mesh.instanceColor.needsUpdate = true;
			}

			function createUI() {
 				// Travel button
 				doneButton = document.createElement('button');
 				doneButton.textContent = "I'm done here!";
 				doneButton.style.cssText = 'position:fixed;top:10px;right:10px;z-index:30;padding:10px 18px;font-family:system-ui,Segoe UI,sans-serif;font-size:14px;font-weight:600;cursor:pointer;background:linear-gradient(135deg,#ff0040,#ff7a18);color:#fff;border:none;border-radius:24px;box-shadow:0 4px 12px rgba(0,0,0,.4);transition:filter .25s, transform .15s;opacity:.55;';
 				doneButton.disabled = true; // enabled after experiment actually begins
 				doneButton.onmouseenter = ()=> { if(!doneButton.disabled) doneButton.style.filter='brightness(1.15)'; };
 				doneButton.onmouseleave = ()=> doneButton.style.filter='';
 				doneButton.onmousedown = ()=> { if(!doneButton.disabled) doneButton.style.transform='scale(.94)'; };
 				doneButton.onmouseup = ()=> doneButton.style.transform='';
 				document.body.appendChild( doneButton );

 				// Loading / travel overlay
 				loadingOverlay = document.createElement('div');
 				loadingOverlay.className = 'loading-gradient';
 				loadingOverlay.style.cssText = 'position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;color:#fff;font-family:system-ui,Segoe UI,sans-serif;z-index:40;';
 				const badge = document.createElement('div');
 				badge.className = 'travel-badge';
 				badge.id = 'travelBadge';
				badge.textContent = 'TRAVEL 0';
				loadingOverlay.appendChild( badge );
				const spinner = document.createElement('div'); spinner.className = 'loader-spinner'; loadingOverlay.appendChild( spinner );
				loadingText = document.createElement('div'); loadingText.className = 'status-line'; loadingText.textContent = 'Preparing jump...'; loadingOverlay.appendChild( loadingText );
				const pw = document.createElement('div'); pw.className = 'progress-wrapper';
				const pb = document.createElement('div'); pb.className = 'progress-bar';
				const pf = document.createElement('div'); pf.className = 'progress-fill'; pf.id = 'progressFill';
				pb.appendChild( pf ); pw.appendChild( pb ); loadingOverlay.appendChild( pw );
				document.body.appendChild( loadingOverlay );

 			function createInstructionOverlay(){
				instructionOverlay = document.createElement('div');
				instructionOverlay.style.cssText='position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 40% 35%,#140016,#050505 70%);color:#fff;font-family:system-ui,Segoe UI,sans-serif;z-index:90;flex-direction:column;padding:24px;';
				const wrap = document.createElement('div');
				wrap.style.cssText='max-width:760px;width:100%;display:grid;gap:26px;background:rgba(255,255,255,0.05);backdrop-filter:blur(10px);padding:36px 44px;border-radius:30px;box-shadow:0 14px 50px -10px #ff004060,0 0 0 1px rgba(255,255,255,0.09);';
				wrap.innerHTML = `
					<div>
						<h2 style='margin:0 0 10px;font-weight:600;letter-spacing:.5px;font-size:30px;'>Instructions</h2>
						<p style='margin:0;line-height:1.5;font-size:15px;opacity:.9'>Harvest the <strong style='color:#ff4d7a;'>bright pink cherries</strong>. Other berries are distractors—feel free to reject them. Each environment patch is a 3D cluster of berries you can rotate and inspect before moving on. After you're done harvesting in a patch, press <em>"I'm done here!"</em> to travel. There are <strong>${maxTrials}</strong> patches total.</p>
					</div>
					<div style='display:grid;gap:16px;'>
						<div style='font-weight:600;letter-spacing:.5px;font-size:12.5px;opacity:.85;text-transform:uppercase;'>Color Legend</div>
						<div style='display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:16px;'>
							<div style='display:flex;gap:10px;'>
								<span style='width:26px;height:26px;border-radius:50%;background:#ff0040;box-shadow:0 0 6px #ff0040 inset,0 0 6px #ff3f7f;'></span>
								<div style='font-size:13px;line-height:1.35'><strong style='color:#ff5d8f;'>Bright Pink</strong><br><em style='opacity:.7'>TARGET — left click to harvest</em></div>
							</div>
							<div style='display:flex;gap:10px;'>
								<span style='width:26px;height:26px;border-radius:50%;background:#8b0000;box-shadow:0 0 6px #8b0000 inset;'></span>
								<div style='font-size:13px;line-height:1.35'><strong style='color:#ff9a85;'>Dark Red</strong><br><em style='opacity:.7'>DISTRACTOR — right click to reject</em></div>
							</div>
							<div style='display:flex;gap:10px;'>
								<span style='width:26px;height:26px;border-radius:50%;background:#228b22;box-shadow:0 0 6px #228b22 inset;'></span>
								<div style='font-size:13px;line-height:1.35'><strong style='color:#4ad54a;'>Green</strong><br><em style='opacity:.7'>DISTRACTOR — right click to reject</em></div>
							</div>
							<div style='display:flex;gap:10px;'>
								<span style='width:26px;height:26px;border-radius:50%;background:#006400;box-shadow:0 0 6px #006400 inset;'></span>
								<div style='font-size:13px;line-height:1.35'><strong style='color:#35c835;'>Dark Green</strong><br><em style='opacity:.7'>DISTRACTOR — right click to reject</em></div>
							</div>
						</div>
					</div>
					<div style='display:grid;gap:10px;'>
						<div style='font-weight:600;letter-spacing:.5px;font-size:12.5px;opacity:.85;text-transform:uppercase;'>Controls</div>
						<ul style='margin:0;padding:0;list-style:none;display:grid;gap:8px;font-size:13.2px;line-height:1.45;'>
							<li><strong style='color:#ff5d8f;'>Rotate View:</strong> Click & drag empty space (left mouse) to orbit.</li>
							<li><strong style='color:#ffca7a;'>Harvest Target:</strong> LEFT click bright pink cherry.</li>
							<li><strong style='color:#ffa07a;'>Reject Distractor:</strong> RIGHT click any non-pink berry.</li>
							<li><strong style='color:#ffc34d;'>Travel:</strong> Press the <em>"I'm done here!"</em> button when satisfied; next patch loads after a ~20s jump sequence.</li>
						</ul>
					</div>
					<div style='font-size:12px;opacity:.6;'>Data (clicks & timing) is recorded continuously until the final patch.</div>
					<div style='display:flex;justify-content:center;'>
						<button id='beginBtn' style='margin-top:4px;padding:14px 34px;font-size:16px;font-weight:600;border:none;border-radius:18px;background:linear-gradient(135deg,#ff0040,#ff7a18);color:#fff;cursor:pointer;box-shadow:0 8px 24px -8px #ff0040b0,0 0 0 1px rgba(255,255,255,0.16);letter-spacing:.5px;'>Begin Foraging ▶</button>
					</div>
				`;
				instructionOverlay.appendChild(wrap);
				document.body.appendChild(instructionOverlay);
				beginButton = wrap.querySelector('#beginBtn');
				beginButton.addEventListener('click', ()=>{
					if(experimentStartTime) return; // already started
					// Reset rotation tracking for main experiment
					rotationCount = 0;
					rotationTimestamps = [];
					firstRotationTime = null;
					isDragging = false;
					lastDragEndTime = 0;
					// Record initial camera angles for first trial
					recordInitialCameraAngles();
					experimentStartTime = performance.now();
					travelCount = 1;
					currentTrialStart = performance.now();
					lastClickGlobalTime = null;
					estimateRefreshRate();
					document.getElementById('travelBadge').textContent = `TRAVEL ${travelCount}`;
					doneButton.disabled = false; doneButton.style.opacity = 1;
					recordLayoutSnapshot(travelCount); // capture initial layout BEFORE any clicks
					instructionOverlay.style.opacity = 1;
					instructionOverlay.style.transition='opacity .55s';
					instructionOverlay.style.opacity=0;
					setTimeout(()=> instructionOverlay.remove(), 600);
				});
			}
				// (duplicate construction removed – already built above)
			}

			function createParticipantForm() {
				participantOverlay = document.createElement('div');
				participantOverlay.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 40% 35%,#1a001d,#030303 70%);color:#fff;font-family:system-ui,Segoe UI,sans-serif;z-index:100;flex-direction:column;padding:20px;';
				participantOverlay.setAttribute('data-role','participant-overlay');
				const fb = document.getElementById('fallback-guide'); if(fb) fb.remove();
				const panel = document.createElement('div');
				panel.style.cssText = 'background:rgba(255,255,255,0.05);backdrop-filter:blur(10px);padding:28px 36px;border-radius:24px;box-shadow:0 10px 40px -10px #ff004080,0 0 0 1px rgba(255,255,255,0.08);max-width:420px;width:100%;';
				panel.innerHTML = `
					<h2 style="margin:0 0 10px;font-weight:600;letter-spacing:.5px">Participant Info</h2>
					<p style="margin:0 0 18px;line-height:1.45;font-size:14px;opacity:.85">Enter your details. You'll see full color legend & controls next.</p>
					<label style='display:block;font-size:13px;margin:0 0 4px'>Name</label>
					<input id='pName' style='width:100%;padding:8px 10px;border-radius:8px;border:1px solid #444;background:#111;color:#fff;margin:0 0 14px;font-size:14px' placeholder='Your name' value='Agent' />
					<label style='display:block;font-size:13px;margin:0 0 4px'>Age</label>
					<input id='pAge' type='number' min='0' style='width:100%;padding:8px 10px;border-radius:8px;border:1px solid #444;background:#111;color:#fff;margin:0 0 14px;font-size:14px' placeholder='Age' value='25' />
					<label style='display:block;font-size:13px;margin:0 0 4px'>Gender</label>
					<select id='pGender' style='width:100%;padding:8px 10px;border-radius:8px;border:1px solid #444;background:#111;color:#fff;margin:0 0 26px;font-size:14px'>
						<option value='' disabled hidden>Select</option>
						<option value='female' selected>Female</option>
						<option value='male'>Male</option>
						<option value='nonbinary'>Non-binary</option>
						<option value='prefer_not'>Prefer not to say</option>
					</select>
					<button id='startBtn' style='width:100%;padding:12px 16px;font-size:15px;font-weight:600;border:none;border-radius:14px;background:linear-gradient(135deg,#ff0040,#ff7a18);color:#fff;cursor:pointer;box-shadow:0 6px 18px -6px #ff0040b0,0 0 0 1px rgba(255,255,255,0.15);'>Continue →</button>
				`;
				participantOverlay.appendChild(panel);
				document.body.appendChild(participantOverlay);
				startButton = panel.querySelector('#startBtn');
				startButton.addEventListener('click', ()=>{
					const name = panel.querySelector('#pName').value.trim();
					const age = panel.querySelector('#pAge').value.trim();
					const gender = panel.querySelector('#pGender').value;
					if(!name || !age || !gender){
						startButton.textContent = 'Fill all fields';
						setTimeout(()=> startButton.textContent='Continue →', 1400);
						return;
					}
					participant = { name, age, gender };
					participantOverlay.style.opacity = 1;
					participantOverlay.style.transition = 'opacity .45s';
					participantOverlay.style.opacity = 0;
					setTimeout(()=>{ participantOverlay.remove(); createInstructionOverlay(); }, 480);
				});
			}

			function createInstructionOverlay(){
				instructionOverlay = document.createElement('div');
				instructionOverlay.style.cssText='position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 40% 35%,#140016,#050505 70%);color:#fff;font-family:system-ui,Segoe UI,sans-serif;z-index:95;flex-direction:column;padding:24px;';
				instructionOverlay.setAttribute('data-role','instruction-overlay');
				const wrap = document.createElement('div');
				wrap.style.cssText='max-width:760px;width:100%;display:grid;gap:26px;background:rgba(255,255,255,0.05);backdrop-filter:blur(10px);padding:36px 44px;border-radius:30px;box-shadow:0 14px 50px -10px #ff004060,0 0 0 1px rgba(255,255,255,0.09);';
				wrap.innerHTML = `
					<div>
						<h2 style='margin:0 0 10px;font-weight:600;letter-spacing:.5px;font-size:30px;'>Instructions</h2>
						<p style='margin:0;line-height:1.5;font-size:15px;opacity:.9'>Harvest the <strong style='color:#ff4d7a;'>bright pink cherries</strong>. Other berries are distractors—reject or ignore them. Rotate the cluster before deciding to travel. There are <strong>${maxTrials}</strong> patches.</p>
					</div>
					<div style='display:grid;gap:16px;'>
						<div style='font-weight:600;letter-spacing:.5px;font-size:12.5px;opacity:.85;text-transform:uppercase;'>Color Legend</div>
						<div style='display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:16px;'>
							<div style='display:flex;gap:10px;'>
								<span style='width:26px;height:26px;border-radius:50%;background:#ff0040;box-shadow:0 0 6px #ff0040 inset,0 0 6px #ff3f7f;'></span>
								<div style='font-size:13px;line-height:1.35'><strong style='color:#ff5d8f;'>Bright Pink</strong><br><em style='opacity:.7'>Target — LEFT click</em></div>
							</div>
							<div style='display:flex;gap:10px;'>
								<span style='width:26px;height:26px;border-radius:50%;background:#8b0000;box-shadow:0 0 6px #8b0000 inset;'></span>
								<div style='font-size:13px;line-height:1.35'><strong style='color:#ff9a85;'>Dark Red</strong><br><em style='opacity:.7'>Distractor — RIGHT click</em></div>
							</div>
							<div style='display:flex;gap:10px;'>
								<span style='width:26px;height:26px;border-radius:50%;background:#228b22;box-shadow:0 0 6px #228b22 inset;'></span>
								<div style='font-size:13px;line-height:1.35'><strong style='color:#4ad54a;'>Green</strong><br><em style='opacity:.7'>Distractor — RIGHT click</em></div>
							</div>
							<div style='display:flex;gap:10px;'>
								<span style='width:26px;height:26px;border-radius:50%;background:#006400;box-shadow:0 0 6px #006400 inset;'></span>
								<div style='font-size:13px;line-height:1.35'><strong style='color:#35c835;'>Dark Green</strong><br><em style='opacity:.7'>Distractor — RIGHT click</em></div>
							</div>
						</div>
					</div>
					<div style='display:grid;gap:10px;'>
						<div style='font-weight:600;letter-spacing:.5px;font-size:12.5px;opacity:.85;text-transform:uppercase;'>Controls</div>
						<ul style='margin:0;padding:0;list-style:none;display:grid;gap:8px;font-size:13.2px;line-height:1.45;'>
							<li><strong style='color:#ff5d8f;'>Rotate:</strong> Click & drag empty space (left mouse)</li>
							<li><strong style='color:#ffca7a;'>Harvest:</strong> LEFT click bright pink target</li>
							<li><strong style='color:#ffa07a;'>Reject:</strong> RIGHT click any distractor</li>
							<li><strong style='color:#ffc34d;'>Travel:</strong> Use "I'm done here!" (20s jump)</li>
						</ul>
					</div>
					<div style='font-size:12px;opacity:.6;'>Clicks & timing logged until last patch.</div>
					<div style='display:flex;gap:12px;justify-content:center;margin-top:4px;'>
							<button id='backInfoBtn' style='padding:12px 20px;font-size:14px;font-weight:600;border:none;border-radius:14px;background:#444;color:#fff;cursor:pointer;'>← Back</button>
							<button id='practiceBtn' style='padding:14px 28px;font-size:15px;font-weight:600;border:none;border-radius:18px;background:#555;color:#fff;cursor:pointer;'>Start Practice</button>
							<button id='beginBtn' style='padding:14px 32px;font-size:16px;font-weight:600;border:none;border-radius:18px;background:linear-gradient(135deg,#ff0040,#ff7a18);color:#fff;cursor:pointer;box-shadow:0 8px 24px -8px #ff0040b0,0 0 0 1px rgba(255,255,255,0.16);letter-spacing:.5px;display:none;'>Begin Main ▶</button>
					</div>`;
				instructionOverlay.appendChild(wrap);
				document.body.appendChild(instructionOverlay);
				const backBtn = wrap.querySelector('#backInfoBtn');
					const practiceBtn = wrap.querySelector('#practiceBtn');
				beginButton = wrap.querySelector('#beginBtn');
				backBtn.addEventListener('click', ()=>{
					if(practiceMode){
						console.log('[Practice] Back button ignored during practice');
						return;
					}
					console.log('[UI] Back to participant form');
					instructionOverlay.remove();
					createParticipantForm();
				});
					practiceBtn.addEventListener('click', ()=>{
						if(practiceMode) return;
						practiceMode = true;
						suppressOverlayRecovery = true;
						practiceBtn.disabled = true; practiceBtn.style.opacity = .5;
					// disable back button while practicing to avoid accidental navigation
					backBtn.disabled = true; backBtn.style.opacity = .35; backBtn.style.pointerEvents='none';
					console.log('[Practice] Starting practice mode');
						generatePracticeBerries();
						createPracticeHint();
						// remove overlay entirely so user can interact with scene
						instructionOverlay.style.transition='opacity .45s';
						instructionOverlay.style.opacity=0;
						setTimeout(()=>{ instructionOverlay.remove(); createPracticeControlPanel(); }, 480);
						// safety: regenerate in case earlier call occurred before WebGL ready
						setTimeout(()=>{ if(practiceMode && !mesh) { console.log('[Practice] Retrying practice berry generation'); generatePracticeBerries(); } }, 800);
						// hide travel button during practice (no meaning yet)
						doneButton.style.display='none';
					});
				beginButton.addEventListener('click', startMainExperiment);
			}

			// Fallback: if overlays fail to appear, recreate on load
			window.addEventListener('load', ()=>{
				setTimeout(()=>{
					if(!participantOverlay && !experimentStartTime) {
						createParticipantForm();
					}
				}, 800);
			});

			function ensureAppreciationOverlay(){
				if(appreciationOverlay) return;
				appreciationOverlay = document.createElement('div');
				appreciationOverlay.style.cssText='position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;background:radial-gradient(circle at 40% 35%,#1d001d,#060606 70%);color:#fff;font-family:system-ui,Segoe UI,sans-serif;z-index:120;padding:30px;text-align:center;';
				appreciationOverlay.innerHTML = `
					<h2 style='margin:0 0 12px;font-size:30px;font-weight:600;letter-spacing:.5px'>Thank You!</h2>
					<p style='max-width:560px;line-height:1.45;font-size:15px;opacity:.9;margin:0 0 26px'>Your participation helps us understand visual foraging behavior. A CSV file download should have started automatically. You can also download it again below.</p>
					<div style='display:flex;gap:14px;flex-wrap:wrap;justify-content:center'>
						<button id='downloadAgainBtn' style='padding:12px 20px;font-size:15px;font-weight:600;border:none;border-radius:14px;background:linear-gradient(135deg,#ff0040,#ff7a18);color:#fff;cursor:pointer;box-shadow:0 6px 18px -6px #ff0040b0,0 0 0 1px rgba(255,255,255,0.15);'>Download Data Again</button>
					</div>
				`;
				document.body.appendChild(appreciationOverlay);
				appreciationOverlay.querySelector('#downloadAgainBtn').addEventListener('click', exportCSV);
			}

			function onTravel() {
				if ( loadingOverlay.style.display !== 'none' && loadingOverlay.style.display !== '' ) return;
				if(!experimentStartTime) return; // guard if experiment not begun
				// finalize current trial summary
				summarizeCurrentTrial();
				if ( travelCount >= maxTrials ) { // finish experiment instead of new travel
					endExperiment(true); // already summarized
					return;
				}
				travelCount++;
				document.getElementById('travelBadge').textContent = `TRAVEL ${travelCount}`;
				doneButton.disabled = true;
				doneButton.style.filter = 'grayscale(1)';
				doneButton.style.cursor = 'not-allowed';
				loadingOverlay.style.display = 'flex';
				const total = 5000; // 5s
				const start = performance.now();
				updateProgress(0, total);
				function frame(now){
					const elapsed = now - start;
					const clamped = Math.min(elapsed, total);
					updateProgress(clamped, total);
					if ( clamped < total ) requestAnimationFrame(frame); else finishTravel();
				}
				requestAnimationFrame(frame);
			}

			function updateProgress(elapsed, total){
				const pct = elapsed / total;
				const secsLeft = Math.ceil((total - elapsed)/1000);
				const pf = document.getElementById('progressFill');
				if ( pf ) pf.style.setProperty('--p', (pct*100).toFixed(1)+'%');
				if ( pf ) pf.style.width = (pct*100)+'%';
				loadingText.textContent = pct < 1 ? `Spooling field... ${Math.round(pct*100)}% | ${secsLeft}s` : 'Finalizing terrain...';
			}

			function finishTravel() {
				generateBerries();
				recordLayoutSnapshot(travelCount); // capture new patch layout before interaction
				// Reset camera rotation tracking for new trial
				rotationCount = 0;
				rotationTimestamps = [];
				firstRotationTime = null;
				isDragging = false;
				lastDragEndTime = 0;
				orientationData.length = 0; // clear orientation log for new trial
				// Reset camera to standard view for each new patch
				camera.position.set( amount, amount, amount );
				camera.lookAt( 0, 0, 0 );
				controls.reset(); // reset orbit controls to initial state
				// Record initial camera angles after reset (baseline for this trial)
				recordInitialCameraAngles();
				loadingText.textContent = 'Deployed!';
				setTimeout(()=>{
					loadingOverlay.style.display = 'none';
					doneButton.disabled = false;
					doneButton.style.filter = '';
					doneButton.style.cursor = 'pointer';
					currentTrialStart = performance.now();
					lastClickGlobalTime = null;
				}, 450);
			}

			function onPointerDown( event ) {
				const now = performance.now();
				if ( now - lastPickTime < 40 ) { return; } // debounce duplicate synthetic events
				lastPickTime = now;
				const btn = event.button;
				if ( btn !== 0 && btn !== 2 ) return;
				if(!experimentStartTime && !practiceMode) return; // ignore clicks before start (unless practice)
				const rect = renderer.domElement.getBoundingClientRect();
				const cx = event.clientX - rect.left;
				const cy = event.clientY - rect.top;
				mouse.x = ( cx / rect.width ) * 2 - 1;
				mouse.y = - ( cy / rect.height ) * 2 + 1;
				const picked = pickInstance( { clientX: event.clientX, clientY: event.clientY } );
				if ( picked === -1 ) return;
				if ( !visibleBerries[picked] ) return;
				mesh.getColorAt( picked, color );
				visibleBerries[picked] = false;
				const hideMatrix = new THREE.Matrix4(); hideMatrix.setPosition( 1e6, 1e6, 1e6 );
				mesh.setMatrixAt( picked, hideMatrix ); mesh.instanceMatrix.needsUpdate = true;
				const colorHex = color.getHexString();
				const isTarget = !!isTargetInstance[picked];
				const action = btn === 0 ? 'LEFT_PICK' : 'RIGHT_REJECT';
				if(practiceMode){
					const correct = (btn === 0 && isTarget) || (btn === 2 && !isTarget);
					showPracticeFeedback(correct, isTarget, action, event.clientX, event.clientY);
					return; // do not log data during practice
				}
				const globalTimeMs = Math.round(now - experimentStartTime);
				const trialTimeMs = Math.round(now - currentTrialStart);
				let rtPrevMs = '';
				if(lastClickGlobalTime !== null) rtPrevMs = globalTimeMs - lastClickGlobalTime;
				lastClickGlobalTime = globalTimeMs;
				clickData.push({
					participant: participant.name,
					age: participant.age,
					gender: participant.gender,
					trial: travelCount,
					globalTimeMs,
					trialTimeMs,
					rtPrevMs,
					instanceId: picked,
					colorHex: '0x'+colorHex,
					colorCategory: isTarget ? 'TARGET' : 'DISTRACTOR',
					action,
					screenX: event.clientX,
					screenY: event.clientY
				});
				console.log( action + ' id='+picked + ' color='+colorHex + ' target='+isTarget );
			}

			// Attempt raycast first, fallback to screen-space nearest instance
			function pickInstance( event ) {
				raycaster.setFromCamera( mouse, camera );
				const hits = raycaster.intersectObject( mesh, false );
				if ( hits.length && hits[0].instanceId !== undefined ) {
					console.log('Raycast hit id=', hits[0].instanceId);
					return hits[0].instanceId;
				}
				// fallback: screen-space nearest
				let bestId = -1; let bestDist = 60; // allow larger threshold
				const w = renderer.domElement.clientWidth; const h = renderer.domElement.clientHeight;
				const pointerX = event.clientX; const pointerY = event.clientY;
				const v = new THREE.Vector3();
				let considered = 0;
				for ( let i = 0; i < count; i++ ) {
					if ( !visibleBerries[i] ) continue;
					v.copy( instancePositions[i] ).project( camera );
					if ( v.z < -1 || v.z > 1 ) continue; // behind camera or clipped
					const sx = ( v.x * 0.5 + 0.5 ) * w;
					const sy = ( - v.y * 0.5 + 0.5 ) * h;
					const dx = sx - pointerX; const dy = sy - pointerY;
					const dist = Math.hypot( dx, dy );
					if ( dist < bestDist ) { bestDist = dist; bestId = i; }
					considered++;
				}
				console.log('Fallback considered', considered, 'instances. Chosen id=', bestId, 'dist=', bestDist.toFixed(1));
				return bestId;
			}

			// legacy helper kept empty
			function hideBerry() {}

			function summarizeCurrentTrial(){
				if(!experimentStartTime || travelCount === 0) return;
				if(lastSummarizedTrial === travelCount) return; // already done
				const trialClicks = clickData.filter(c=> c.trial === travelCount);
				if(!trialClicks.length) { // still push empty summary
					trialData.push({ 
						trial: travelCount, 
						targetsPicked:0, 
						targetsRejected:0, 
						distractorsPicked:0, 
						distractorsRejected:0, 
						totalClicks:0, 
						rotationCount: rotationCount, 
						firstRotationTime: firstRotationTime ?? '', 
						rotationIntervals: 'NA',
						initialAzimuthal: initialCameraAngles.azimuthal,
						initialPolar: initialCameraAngles.polar
					});
					lastSummarizedTrial = travelCount;
					return;
				}
				let targetsPicked=0, targetsRejected=0, distractorsPicked=0, distractorsRejected=0;
				trialClicks.forEach(c=>{
					if(c.colorCategory==='TARGET') {
						if(c.action==='LEFT_PICK') targetsPicked++; else targetsRejected++;
					} else {
						if(c.action==='LEFT_PICK') distractorsPicked++; else distractorsRejected++;
					}
				});
				// Build rotation intervals or mark NA if fewer than 2 rotations
				let intervals;
				if(rotationTimestamps.length < 2){
					intervals = ['NA'];
				} else {
					let rawIntervals = [];
					for(let i=1;i<rotationTimestamps.length;i++){
						rawIntervals.push(rotationTimestamps[i]-rotationTimestamps[i-1]);
					}
					// Sanitize: remove non-positive, merge small gaps (<60ms) into previous
					intervals = [];
					rawIntervals.forEach(iv=>{
						if(iv <= 0) return;
						if(iv < 60 && intervals.length){
							intervals[intervals.length-1] += iv;
						} else {
							intervals.push(iv);
						}
					});
				}
				trialData.push({
					trial: travelCount,
					targetsPicked,
					targetsRejected,
					distractorsPicked,
					distractorsRejected,
					totalClicks: trialClicks.length,
					rotationCount,
					firstRotationTime: firstRotationTime ?? '',
					rotationIntervals: intervals.join(' '),
					initialAzimuthal: initialCameraAngles.azimuthal,
					initialPolar: initialCameraAngles.polar
				});
				lastSummarizedTrial = travelCount;
			}

			function endExperiment(alreadySummarized=false){
				// finalize last trial if not already summarized
				if(!alreadySummarized) summarizeCurrentTrial();
				exportCSV();
				ensureAppreciationOverlay();
				appreciationOverlay.style.display='flex';
			}

			function exportCSV(){
				const lines = [];
				lines.push('participant,name,'+participant.name);
				lines.push('participant,age,'+participant.age);
				lines.push('participant,gender,'+participant.gender);
				lines.push('meta,maxTrials,'+maxTrials);
				lines.push('meta,screenWidth,'+window.innerWidth);
				lines.push('meta,screenHeight,'+window.innerHeight);
				lines.push('meta,refreshHz,'+(estimatedRefreshHz || 'NA'));
				lines.push('');
				lines.push('TRIAL_LAYOUT');
				lines.push('trial,targetCount,distractorCount,targetIds,distractorIds');
				layoutData.forEach(l=>{
					lines.push([l.trial,l.targetCount,l.distractorCount,'['+l.targetIds.join(' ')+']','['+l.distractorIds.join(' ')+']'].join(','));
				});
				lines.push('');
				lines.push('CLICK_DATA');
				lines.push('participant,age,gender,trial,globalTimeMs,trialTimeMs,rtPrevMs,instanceId,colorHex,colorCategory,action,screenX,screenY');
				clickData.forEach(c=>{
					lines.push([c.participant,c.age,c.gender,c.trial,c.globalTimeMs,c.trialTimeMs,c.rtPrevMs,c.instanceId,c.colorHex,c.colorCategory,c.action,c.screenX,c.screenY].join(','));
				});
				lines.push('');
				lines.push('TRIAL_SUMMARY');
				lines.push('trial,targetsPicked,targetsRejected,distractorsPicked,distractorsRejected,totalClicks,rotationCount,firstRotationTime,rotationIntervals,initialAzimuthal,initialPolar');
				trialData.forEach(t=>{
					lines.push([t.trial,t.targetsPicked,t.targetsRejected,t.distractorsPicked,t.distractorsRejected,t.totalClicks,t.rotationCount ?? '',t.firstRotationTime ?? '',`[${t.rotationIntervals??''}]`,t.initialAzimuthal ?? '',t.initialPolar ?? ''].join(','));
				});
				const csv = lines.join('\n');
				const blob = new Blob([csv], { type: 'text/csv' });
				const stamp = new Date().toISOString().replace(/[:T]/g,'-').split('.')[0];
				const safeName = participant.name.replace(/[^a-z0-9_-]+/gi,'_');
				const fileName = `${safeName || 'participant'}_${participant.age || 'NA'}_${participant.gender || 'NA'}_${stamp}.csv`;
				const a = document.createElement('a');
				a.href = URL.createObjectURL(blob);
				a.download = fileName;
				document.body.appendChild(a);
				a.click();
				setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 2000);
			}

			function estimateRefreshRate(){
				// Measure ~60 frame intervals and average
				const samples = [];
				let lastTs = null;
				function frame(ts){
					if(lastTs !== null){ samples.push(ts - lastTs); }
					lastTs = ts;
					if(samples.length < 60) requestAnimationFrame(frame); else {
						const avg = samples.reduce((a,b)=>a+b,0)/samples.length;
						if(avg>0) estimatedRefreshHz = Math.round(1000/avg);
					}
				}
				requestAnimationFrame(frame);
			}

			function recordLayoutSnapshot(trial){
				// Avoid duplicate snapshot for same trial (e.g., accidental second call)
				if(layoutData.length && layoutData[layoutData.length-1].trial === trial) return;
				const targetIds = [];
				const distractorIds = [];
				for(let i=0;i<count;i++){
					if(!visibleBerries[i]) continue; // all visible at start, check anyway
					if(isTargetInstance[i]) targetIds.push(i); else distractorIds.push(i);
				}
				layoutData.push({
					trial,
					targetCount: targetIds.length,
					distractorCount: distractorIds.length,
					targetIds,
					distractorIds
				});
			}

			function recordInitialCameraAngles() {
				// Calculate spherical coordinates from camera position relative to target (0,0,0)
				const pos = camera.position.clone();
				const radius = pos.length();
				const azimuthal = Math.atan2(pos.x, pos.z); // angle around Y axis
				const polar = Math.acos(pos.y / radius); // angle from Y axis
				
				initialCameraAngles = {
					azimuthal: Math.round(azimuthal * 180 / Math.PI * 100) / 100, // degrees, 2 decimal places
					polar: Math.round(polar * 180 / Math.PI * 100) / 100
				};
				console.log('[Camera] Initial angles for trial', travelCount, '- azimuthal:', initialCameraAngles.azimuthal, 'polar:', initialCameraAngles.polar);
			}

			// ---------------- PRACTICE MODE SUPPORT ----------------
			let practiceHintEl = null;
			function generatePracticeBerries(){
				// simplified small set for practice (regardless of amount)
				console.log('[Practice] Generating practice berries');
				const practiceTotal = Math.min(60, count); // smaller for practice
				isTargetInstance = new Array(count).fill(false);
				visibleBerries = new Array(count).fill(false);
				instancePositions = new Array(count);
				if(mesh){ scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose(); }
				const geometry = new THREE.IcosahedronGeometry( 0.5, 3 ); // same as main
				const material = new THREE.MeshPhongMaterial( { color: 0xffffff } ); // same as main
				mesh = new THREE.InstancedMesh( geometry, material, count );
				mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
				
				// Create a smaller 4x4x4 grid for practice (centered around origin)
				const practiceAmount = 4;
				const offset = (practiceAmount - 1) / 2;
				const matrix = new THREE.Matrix4();
				let i = 0;
				
				for ( let x = 0; x < practiceAmount && i < practiceTotal; x++ ) {
					for ( let y = 0; y < practiceAmount && i < practiceTotal; y++ ) {
						for ( let z = 0; z < practiceAmount && i < practiceTotal; z++ ) {
							const px = offset - x;
							const py = offset - y;
							const pz = offset - z;
							matrix.setPosition( px, py, pz );
							mesh.setMatrixAt( i, matrix );
							instancePositions[i] = new THREE.Vector3( px, py, pz );
							visibleBerries[i] = true;
							
							// make ~30% targets for practice
							const rand = Math.random();
							if ( rand < 0.3 ) { 
								mesh.setColorAt( i, brightCherry ); 
								isTargetInstance[i] = true; 
							} else if ( rand < 0.6 ) { 
								mesh.setColorAt( i, darkCherry ); 
								isTargetInstance[i] = false; 
							} else if ( rand < 0.8 ) { 
								mesh.setColorAt( i, greenBerry ); 
								isTargetInstance[i] = false; 
							} else { 
								mesh.setColorAt( i, darkGreen ); 
								isTargetInstance[i] = false; 
							}
							i++;
						}
					}
				}
				
				// Hide unused instances
				for(let j=i; j<count; j++){
					const m = new THREE.Matrix4(); 
					m.setPosition(1e6,1e6,1e6); 
					mesh.setMatrixAt(j,m);
					visibleBerries[j] = false;
				}
				
				mesh.instanceMatrix.needsUpdate = true;
				if ( mesh.instanceColor ) mesh.instanceColor.needsUpdate = true;
				scene.add(mesh);
				
				// Position camera to see the practice grid
				camera.position.set( 4, 4, 4 );
				camera.lookAt(0,0,0);
				controls.update(); // update orbit controls
				
				console.log('[Practice] Practice berries added to scene. Visible instances:', i);
			}

			function createPracticeHint(){
				removePracticeHint();
				practiceHintEl = document.createElement('div');
				practiceHintEl.style.cssText='position:fixed;left:50%;top:14px;transform:translateX(-50%);background:rgba(20,20,20,.85);color:#fff;padding:10px 20px;border-radius:40px;font:500 13px system-ui,Segoe UI,sans-serif;letter-spacing:.5px;z-index:50;display:flex;align-items:center;gap:14px;box-shadow:0 4px 18px -6px #000;';
				practiceHintEl.innerHTML = `<span style="color:#ffca7a;font-weight:600;">Practice Mode</span><span style='opacity:.8;'>Try clicking targets (LEFT) and distractors (RIGHT). Feedback will appear.</span>`;
				document.body.appendChild(practiceHintEl);
			}
			function removePracticeHint(){ if(practiceHintEl){ practiceHintEl.remove(); practiceHintEl=null; } }

			function showPracticeFeedback(correct,isTarget,action, x, y){
				const fb = document.createElement('div');
				fb.style.cssText = 'position:fixed;left:'+(x+8)+'px;top:'+(y+8)+'px;padding:6px 10px;border-radius:10px;font:600 12px system-ui,Segoe UI,sans-serif;pointer-events:none;z-index:200;transition:transform .4s, opacity .4s;';
				fb.style.background = correct ? 'linear-gradient(135deg,#0f8a00,#23c423)' : 'linear-gradient(135deg,#8a0000,#c42323)';
				fb.style.color = '#fff';
				const expect = isTarget ? 'LEFT' : 'RIGHT';
				fb.textContent = (correct? 'Correct':'Wrong') + ` (${expect} on ${isTarget?'TARGET':'DISTRACTOR'})`;
				document.body.appendChild(fb);
				requestAnimationFrame(()=>{ fb.style.opacity='1'; fb.style.transform='translateY(0)'; });
				setTimeout(()=>{ fb.style.opacity='0'; fb.style.transform='translateY(-12px) scale(.95)'; }, 600);
				setTimeout(()=> fb.remove(), 1100);
			}

			function createPracticeControlPanel(){
				if(practiceControlPanel) return;
				practiceControlPanel = document.createElement('div');
				practiceControlPanel.style.cssText='position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:14px;align-items:center;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);padding:12px 20px;border-radius:24px;z-index:60;font:500 13px system-ui,Segoe UI,sans-serif;color:#fff;box-shadow:0 4px 18px -6px #000;';
				practiceControlPanel.innerHTML = `
					<span style='opacity:.85;'>Practice Mode — interact freely.</span>
					<button id='beginMainFromPractice' style='padding:10px 18px;font-size:14px;font-weight:600;border:none;border-radius:18px;background:linear-gradient(135deg,#ff0040,#ff7a18);color:#fff;cursor:pointer;box-shadow:0 4px 14px -6px #ff004090;'>Begin Main ▶</button>
				`;
				document.body.appendChild(practiceControlPanel);
				practiceControlPanel.querySelector('#beginMainFromPractice').addEventListener('click', startMainExperiment);
			}

			function removePracticeControlPanel(){ if(practiceControlPanel){ practiceControlPanel.remove(); practiceControlPanel=null; } }

			function startMainExperiment(){
				if(experimentStartTime) return;
				// clean up practice
				removePracticeHint();
				removePracticeControlPanel();
				practiceMode = false;
				suppressOverlayRecovery = false; // allow watchdog after experiment if needed
				generateBerries();
				// Reset camera to proper main experiment position
				camera.position.set( amount, amount, amount );
				camera.lookAt( 0, 0, 0 );
				controls.update(); // update orbit controls
				// Reset rotation tracking for main experiment
				rotationCount = 0;
				rotationTimestamps = [];
				firstRotationTime = null;
				isDragging = false;
				lastDragEndTime = 0;
				orientationData.length = 0;
				// Record initial camera angles for first trial
				recordInitialCameraAngles();
				experimentStartTime = performance.now();
				travelCount = 1;
				currentTrialStart = performance.now();
				lastClickGlobalTime = null;
				estimateRefreshRate();
				document.getElementById('travelBadge').textContent = `TRAVEL ${travelCount}`;
				doneButton.style.display='';
				doneButton.disabled = false; doneButton.style.opacity = 1;
				recordLayoutSnapshot(travelCount);
			}

			function animate() {

				controls.update();

				renderer.render( scene, camera );

				// if ( stats ) stats.update();

			}

		</script>
	</body>
</html>
